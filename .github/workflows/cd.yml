# =============================================================================
# SecureNotes API - CD Pipeline
# =============================================================================
# This pipeline handles deployment and DAST security testing.
# Triggered after CI pipeline completes successfully OR manually.
# =============================================================================

name: CD Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
    branches: [master, main]
  workflow_dispatch:  # Allows manual trigger

env:
  IMAGE_NAME: securenotes-api

jobs:
  # ===========================================================================
  # STAGE 1: DEPLOY - Pull and Run Container (Simulates K8s Deployment)
  # ===========================================================================
  # WHY: Demonstrates deployment capability by pulling the validated image
  # from DockerHub and running it. In production, this would deploy to K8s.
  # ===========================================================================
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    outputs:
      container_id: ${{ steps.run_container.outputs.container_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Pull image from DockerHub
        run: |
          echo "Pulling image from DockerHub..."
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          echo "Image pulled successfully!"

      - name: Run container (Deploy)
        id: run_container
        run: |
          echo "Starting application container..."
          CONTAINER_ID=$(docker run -d --name securenotes-app -p 8080:8080 ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest)
          echo "container_id=$CONTAINER_ID" >> $GITHUB_OUTPUT
          echo "Container started with ID: $CONTAINER_ID"
          sleep 10  # Wait for app to start

      - name: Verify deployment health
        run: |
          echo "Checking application health..."
          for i in {1..5}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health || echo "000")
            if [ "$response" = "200" ]; then
              echo "Health check passed! Application is running."
              curl -s http://localhost:8080/health | jq .
              exit 0
            fi
            echo "Attempt $i: Health check returned $response, retrying..."
            sleep 5
          done
          echo "Health check failed!"
          docker logs securenotes-app
          exit 1

      - name: Test API endpoints
        run: |
          echo "Testing API endpoints..."

          echo "1. Creating a note..."
          CREATE_RESPONSE=$(curl -s -X POST http://localhost:8080/api/v1/notes \
            -H "Content-Type: application/json" \
            -d '{"title":"CD Pipeline Test","content":"Deployed via GitHub Actions CD"}')
          echo "$CREATE_RESPONSE" | jq .
          NOTE_ID=$(echo "$CREATE_RESPONSE" | jq -r '.data.id')

          echo "2. Getting all notes..."
          curl -s http://localhost:8080/api/v1/notes | jq .

          echo "3. Getting specific note..."
          curl -s http://localhost:8080/api/v1/notes/$NOTE_ID | jq .

          echo "4. Updating note..."
          curl -s -X PUT http://localhost:8080/api/v1/notes/$NOTE_ID \
            -H "Content-Type: application/json" \
            -d '{"title":"Updated by CD","content":"CD Pipeline works!"}' | jq .

          echo "5. Deleting note..."
          curl -s -X DELETE http://localhost:8080/api/v1/notes/$NOTE_ID | jq .

          echo "All API tests passed!"

  # ===========================================================================
  # STAGE 2: VALIDATE K8S - Kubernetes Manifest Validation
  # ===========================================================================
  # WHY: Validates Kubernetes manifests are syntactically correct and follow
  # best practices before actual deployment to a cluster.
  # ===========================================================================
  validate-k8s:
    name: Validate K8s Manifests
    runs-on: ubuntu-latest
    needs: [deploy]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Update image in manifests
        run: |
          sed -i "s|IMAGE_PLACEHOLDER|${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest|g" k8s/deployment.yaml

      - name: Validate deployment manifest
        run: |
          echo "Validating deployment.yaml..."
          kubectl apply --dry-run=client --validate=false -f k8s/deployment.yaml
          echo "Deployment manifest is valid!"

      - name: Validate service manifest
        run: |
          echo "Validating service.yaml..."
          kubectl apply --dry-run=client --validate=false -f k8s/service.yaml
          echo "Service manifest is valid!"

      - name: Display K8s manifests
        run: |
          echo "=== Deployment Manifest ==="
          cat k8s/deployment.yaml
          echo ""
          echo "=== Service Manifest ==="
          cat k8s/service.yaml

      - name: K8s deployment instructions
        run: |
          echo "=============================================="
          echo "To deploy to Minikube locally:"
          echo "=============================================="
          echo "1. minikube start"
          echo "2. kubectl apply -f k8s/"
          echo "3. kubectl get pods"
          echo "4. minikube service securenotes-api"
          echo "=============================================="

  # ===========================================================================
  # STAGE 3: DAST - Dynamic Application Security Testing
  # ===========================================================================
  # WHY: Tests the RUNNING application for security vulnerabilities.
  # DAST finds runtime issues like:
  # - Authentication bypasses, Session management flaws
  # - Security misconfigurations, Information disclosure
  # This completes the shift-left security with runtime validation.
  # ===========================================================================
  dast:
    name: DAST (OWASP ZAP)
    runs-on: ubuntu-latest
    needs: [deploy]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Start application for DAST
        run: |
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          docker run -d --name dast-target -p 8080:8080 ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          sleep 10
          curl -s http://localhost:8080/health

      - name: Run OWASP ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.14.0
        with:
          target: 'http://localhost:8080'
          rules_file_name: '.zap/rules.tsv'
          cmd_options: '-a -j'
          allow_issue_writing: false
        continue-on-error: true  # Don't fail pipeline on findings

      - name: Upload ZAP Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: zap-scan-report
          path: report_html.html

      - name: Cleanup
        if: always()
        run: |
          docker rm -f dast-target || true

  # ===========================================================================
  # STAGE 4: DEPLOY TO LOCAL K8S - Self-hosted Runner on Minikube
  # ===========================================================================
  # WHY: Deploys the validated image to local Minikube cluster via a
  # self-hosted runner running on the developer's machine. This demonstrates
  # full GitOps: code change -> CI -> CD -> auto-deploy to K8s.
  # ===========================================================================
  deploy-k8s:
    name: Deploy to Local K8s
    runs-on: self-hosted
    needs: [validate-k8s]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Minikube
        run: |
          echo "Deploying to local Minikube cluster..."
          kubectl apply -f k8s/
          kubectl rollout restart deployment/securenotes-api
          kubectl rollout status deployment/securenotes-api --timeout=120s
          echo "Deployment successful!"

      - name: Verify deployment
        run: |
          sleep 10
          NODE_PORT=$(kubectl get svc securenotes-api -o jsonpath='{.spec.ports[0].nodePort}')
          MINIKUBE_IP=$(minikube ip)
          echo "App running at http://${MINIKUBE_IP}:${NODE_PORT}"
          curl -s http://${MINIKUBE_IP}:${NODE_PORT}/health

  # ===========================================================================
  # STAGE 5: SUMMARY - Deployment Summary
  # ===========================================================================
  summary:
    name: CD Summary
    runs-on: ubuntu-latest
    needs: [deploy, validate-k8s, dast, deploy-k8s]
    if: always()
    steps:
      - name: CD Pipeline Summary
        run: |
          echo "=============================================="
          echo "        CD PIPELINE COMPLETED"
          echo "=============================================="
          echo ""
          echo "Image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest"
          echo ""
          echo "Stages completed:"
          echo "  ✓ Deploy - Application container tested"
          echo "  ✓ Validate K8s - Manifests validated"
          echo "  ✓ DAST - Security scan completed"
          echo "  ✓ Deploy K8s - Deployed to local Minikube"
          echo ""
          echo "=============================================="
